{"ast":null,"code":"\"use strict\";var _objectWithoutProperties=require(\"@babel/runtime/helpers/objectWithoutProperties\");var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _classCallCheck=require(\"@babel/runtime/helpers/classCallCheck\");var _createClass=require(\"@babel/runtime/helpers/createClass\");var _get=require(\"@babel/runtime/helpers/get\");var _inherits=require(\"@babel/runtime/helpers/inherits\");var _possibleConstructorReturn=require(\"@babel/runtime/helpers/possibleConstructorReturn\");var _getPrototypeOf=require(\"@babel/runtime/helpers/getPrototypeOf\");var _excluded=[\"numberOfPointers\",\"direction\"];function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _hammerjs=_interopRequireDefault(require(\"@egjs/hammerjs\"));var _constants=require(\"./constants\");var _Errors=require(\"./Errors\");var _DraggingGestureHandler=_interopRequireDefault(require(\"./DraggingGestureHandler\"));var _utils=require(\"./utils\");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var FlingGestureHandler=function(_DraggingGestureHandl){_inherits(FlingGestureHandler,_DraggingGestureHandl);var _super=_createSuper(FlingGestureHandler);function FlingGestureHandler(){_classCallCheck(this,FlingGestureHandler);return _super.apply(this,arguments);}_createClass(FlingGestureHandler,[{key:\"name\",get:function get(){return'swipe';}},{key:\"NativeGestureClass\",get:function get(){return _hammerjs.default.Swipe;}},{key:\"onGestureActivated\",value:function onGestureActivated(event){this.sendEvent(_objectSpread(_objectSpread({},event),{},{eventType:_hammerjs.default.INPUT_MOVE,isFinal:false,isFirst:true}));this.isGestureRunning=false;this.hasGestureFailed=false;this.sendEvent(_objectSpread(_objectSpread({},event),{},{eventType:_hammerjs.default.INPUT_END,isFinal:true}));}},{key:\"onRawEvent\",value:function onRawEvent(ev){var _this=this;_get(_getPrototypeOf(FlingGestureHandler.prototype),\"onRawEvent\",this).call(this,ev);if(this.hasGestureFailed){return;}if(ev.isFinal){setTimeout(function(){if(_this.isGestureRunning){_this.cancelEvent(ev);}});}else if(!this.hasGestureFailed&&!this.isGestureRunning){var gesture=this.hammer.get(this.name);if(gesture.options.enable(gesture,ev)){this.onStart(ev);this.sendEvent(ev);}}}},{key:\"getHammerConfig\",value:function getHammerConfig(){return{pointers:this.config.numberOfPointers,direction:this.getDirection()};}},{key:\"getTargetDirections\",value:function getTargetDirections(direction){var directions=[];if(direction&_constants.Direction.RIGHT){directions.push(_hammerjs.default.DIRECTION_RIGHT);}if(direction&_constants.Direction.LEFT){directions.push(_hammerjs.default.DIRECTION_LEFT);}if(direction&_constants.Direction.UP){directions.push(_hammerjs.default.DIRECTION_UP);}if(direction&_constants.Direction.DOWN){directions.push(_hammerjs.default.DIRECTION_DOWN);}return directions;}},{key:\"getDirection\",value:function getDirection(){var _this$getConfig=this.getConfig(),direction=_this$getConfig.direction;var directions=[];if(direction&_constants.Direction.RIGHT){directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);}if(direction&_constants.Direction.LEFT){directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);}if(direction&_constants.Direction.UP){directions.push(_hammerjs.default.DIRECTION_VERTICAL);}if(direction&_constants.Direction.DOWN){directions.push(_hammerjs.default.DIRECTION_VERTICAL);}directions=_toConsumableArray(new Set(directions));if(directions.length===0)return _hammerjs.default.DIRECTION_NONE;if(directions.length===1)return directions[0];return _hammerjs.default.DIRECTION_ALL;}},{key:\"isGestureEnabledForEvent\",value:function isGestureEnabledForEvent(_ref,_recognizer,_ref2){var numberOfPointers=_ref.numberOfPointers;var pointerLength=_ref2.maxPointers;var validPointerCount=pointerLength===numberOfPointers;if(!validPointerCount&&this.isGestureRunning){return{failed:true};}return{success:validPointerCount};}},{key:\"updateGestureConfig\",value:function updateGestureConfig(_ref3){var _ref3$numberOfPointer=_ref3.numberOfPointers,numberOfPointers=_ref3$numberOfPointer===void 0?1:_ref3$numberOfPointer,direction=_ref3.direction,props=_objectWithoutProperties(_ref3,_excluded);if((0,_utils.isnan)(direction)||typeof direction!=='number'){throw new _Errors.GesturePropError('direction',direction,'number');}return _get(_getPrototypeOf(FlingGestureHandler.prototype),\"updateGestureConfig\",this).call(this,_objectSpread({numberOfPointers:numberOfPointers,direction:direction},props));}}]);return FlingGestureHandler;}(_DraggingGestureHandler.default);var _default=FlingGestureHandler;exports.default=_default;","map":{"version":3,"sources":["FlingGestureHandler.ts"],"names":["FlingGestureHandler","DraggingGestureHandler","name","NativeGestureClass","Hammer","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","Direction","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props","GesturePropError"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]},"metadata":{},"sourceType":"script"}